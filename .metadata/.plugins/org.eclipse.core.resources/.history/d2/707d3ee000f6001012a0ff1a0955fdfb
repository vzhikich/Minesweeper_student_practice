/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Private variables ---------------------------------------------------------*/
UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */
uint8_t rx_byte;
char rx_buffer[16];
uint8_t rx_index = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);

/* USER CODE BEGIN PFP */
uint8_t Calculate_XOR_Checksum(uint8_t *data, uint16_t length);
/* USER CODE END PFP */

/* USER CODE BEGIN 0 */
#define MAX_SIZE 15
#define MINE     -1

typedef enum { EASY, MEDIUM, HARD } Difficulty;

int8_t minefield[MAX_SIZE][MAX_SIZE];
uint8_t fieldSize;
uint8_t mineCount;

// Ініціалізація генератора випадкових чисел
void RNG_Init(void)
{
    srand(HAL_GetTick());
}

// Очистка поля
void ClearField(void)
{
    for (uint8_t i = 0; i < fieldSize; i++)
        for (uint8_t j = 0; j < fieldSize; j++)
            minefield[i][j] = 0;
}

// Встановлення мін випадковим чином
void PlaceMines(void)
{
    uint8_t placed = 0;
    while (placed < mineCount)
    {
        uint8_t x = rand() % fieldSize;
        uint8_t y = rand() % fieldSize;
        if (minefield[x][y] != MINE)
        {
            minefield[x][y] = MINE;
            placed++;
        }
    }
}

// Генерація поля залежно від рівня складності
void GenerateMinefield(Difficulty level)
{
    switch (level)
    {
        case EASY:   fieldSize = 5;  mineCount = 10; break;
        case MEDIUM: fieldSize = 10; mineCount = 30; break;
        case HARD:   fieldSize = 15; mineCount = 50; break;
    }

    ClearField();
    PlaceMines();
}

// Вивід поля через UART
void PrintMinefield(void)
{
    char buf[4];
    for (uint8_t i = 0; i < fieldSize; i++)
    {
        for (uint8_t j = 0; j < fieldSize; j++)
        {
            if (minefield[i][j] == MINE)
                HAL_UART_Transmit(&huart2, (uint8_t*)" *", 2, 100);
            else
                HAL_UART_Transmit(&huart2, (uint8_t*)" .", 2, 100);
        }
        HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n", 2, 100);
    }
}

// Обробка команди MINE
void ProcessMineCommand(char* cmd)
{
    if (strcmp(cmd, "EASY") == 0) GenerateMinefield(EASY);
    else if (strcmp(cmd, "MEDIUM") == 0) GenerateMinefield(MEDIUM);
    else if (strcmp(cmd, "HARD") == 0) GenerateMinefield(HARD);
    else
    {
        HAL_UART_Transmit(&huart2, (uint8_t*)"Unknown level\r\n", 15, 100);
        return;
    }

    HAL_UART_Transmit(&huart2, (uint8_t*)"Minefield:\r\n", 12, 100);
    PrintMinefield();
}

/* USER CODE END 0 */


int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART2_UART_Init();
    RNG_Init();

    while (1)
    {
        if (HAL_UART_Receive(&huart2, &rx_byte, 1, HAL_MAX_DELAY) == HAL_OK)
        {
            HAL_UART_Transmit(&huart2, &rx_byte, 1, 100);

            if (rx_byte == '\r' || rx_byte == '\n')
            {
                HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n", 2, 100);
                rx_buffer[rx_index] = '\0';

                // XOR checksum
                uint8_t checksum = Calculate_XOR_Checksum((uint8_t*)rx_buffer, strlen(rx_buffer));
                char tx_buf[32];
                snprintf(tx_buf, sizeof(tx_buf), "%s*%02X\r\n", rx_buffer, checksum);
                HAL_UART_Transmit(&huart2, (uint8_t*)tx_buf, strlen(tx_buf), 100);

                if (strncmp(rx_buffer, "MINE ", 5) == 0)
                    ProcessMineCommand(&rx_buffer[5]);

                rx_index = 0;
            }
            else
            {
                if (rx_index < sizeof(rx_buffer) - 1)
                    rx_buffer[rx_index++] = rx_byte;
            }
        }
    }
}

/* USER CODE BEGIN 4 */
uint8_t Calculate_XOR_Checksum(uint8_t *data, uint16_t length)
{
    uint8_t checksum = 0;
    for (uint16_t i = 0; i < length; i++)
        checksum ^= data[i];
    return checksum;
}
/* USER CODE END 4 */

/**
  * @brief System Clock Configuration
  */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) Error_Handler();

    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) Error_Handler();
}

/**
  * @brief USART2 Initialization Function
  */
static void MX_USART2_UART_Init(void)
{
    huart2.Instance = USART2;
    huart2.Init.BaudRate = 115200;
    huart2.Init.WordLength = UART_WORDLENGTH_8B;
    huart2.Init.StopBits = UART_STOPBITS_1;
    huart2.Init.Parity = UART_PARITY_NONE;
    huart2.Init.Mode = UART_MODE_TX_RX;
    huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart2.Init.OverSampling = UART_OVERSAMPLING_16;
    huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
    huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
    if (HAL_UART_Init(&huart2) != HAL_OK) Error_Handler();
}

/**
  * @brief GPIO Initialization Function
  */
static void MX_GPIO_Init(void)
{
    __HAL_RCC_GPIOA_CLK_ENABLE();
}

/**
  * @brief  This function is executed in case of error occurrence.
  */
void Error_Handler(void)
{
    __disable_irq();
    while (1) {}
}
